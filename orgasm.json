[
  {
    "name": "-orgasm-",
    "type": "ayvascript",
    "data": {
      "script": "/**\n * Customizable Parameters\n */\nconst strokeName = \"short-high-roll-backward\";\nconst addTwist = true;\nconst minBpm = 10;\nconst maxBpm = 220;\nconst orgasmLength = 25;\nconst postOrgasmLength = 15;\nconst noise = 0.5;\nconst initialTransitionTime = 1;\n\n/**\n * BPM Randomization Parameters (Using Midpoint Displacement Algorithm)\n * \n * See the following link for details about this algorithm:\n * https://bitesofcode.wordpress.com/2016/12/23/landscape-generation-using-midpoint-displacement\n */\nconst iterations = 5;         // 2^iterations = number of points\nconst reductionFactor = 0.3; // Lower = more erratic. Higher = smoother.\n\nlet controlPoints = [1, 0];\nlet bounds = 0.5;\nfor (let i = 0; i < iterations; i++) {\n  const newControlPoints = [];\n\n  for (let j = 0; j < controlPoints.length - 1; j++) {\n    const left = controlPoints[j];\n    const right = controlPoints[j + 1];\n    const midpoint = (left + right) / 2;\n    const displacement = Ayva.map(Math.random(), 0, 1, -bounds, bounds);\n\n    newControlPoints.push(left);\n    newControlPoints.push(Math.min(1, Math.max(0, midpoint + displacement)));\n\n    if (j === controlPoints.length - 2) {\n      newControlPoints.push(right);\n    }\n  }\n\n  controlPoints = newControlPoints;\n  bounds = bounds * (1 / Math.pow(2, reductionFactor));\n}\n\nconst bpmControlPoints = controlPoints.map((point) =>\n  Ayva.map(point, 0, 1, minBpm, maxBpm)\n);\n\n/**\n * Setup\n */\nconst currentStroke = GLOBALS.input;\nconst strokeConfig = TempestStroke.library[strokeName];\n\nObject.keys(strokeConfig).forEach((axis) => {\n  // Add noise to each axis if not already present.\n  strokeConfig[axis].noise = strokeConfig[axis].noise || noise;\n});\n\nconst currentTwist = strokeConfig.R0 || strokeConfig.twist;\n\nif (\n  addTwist &&\n  (!currentTwist || (currentTwist.from === 0.5 && currentTwist.to === 0.5))\n) {\n  // Add a random twist if not already present.\n  strokeConfig.twist = {\n    from: Ayva.map(Math.random(), 0, 1, 0.1, 0.3),\n    to: Ayva.map(Math.random(), 0, 1, 0.7, 0.9),\n    phase: 1,\n    ecc: Math.random(),\n    noise,\n  };\n}\n\nconst duration = new VariableDuration(orgasmLength);\n\nconst bpmProvider = () => {\n  // Follow the curve specified via bpmControlPoints.\n  const progress = duration.percentage * (bpmControlPoints.length - 1);\n  const index = Math.floor(progress);\n\n  if (index >= bpmControlPoints.length - 1) {\n    return bpmControlPoints[bpmControlPoints.length - 1];\n  }\n\n  const start = bpmControlPoints[index];\n  const end = bpmControlPoints[index + 1];\n\n  const result = Ayva.map(\n    index ? progress % index : progress,\n    0,\n    1,\n    start,\n    end\n  );\n\n  return result;\n};\n\nlet finishStroke;\nif (currentStroke) {\n  // If a stroke is already playing, transition out of it.\n  finishStroke = currentStroke.transition(\n    strokeConfig,\n    bpmProvider,\n    initialTransitionTime\n  );\n} else {\n  finishStroke = new TempestStroke(strokeConfig, bpmProvider).bind(ayva);\n}\n\n/**\n * Perform Stroke\n */\nwhile (!duration.complete) {\n  yield finishStroke.next();\n}\n\n/**\n * Perform strokes at the slowest speed for a little while...\n */\nconst postOrgasmDuration = new VariableDuration(postOrgasmLength);\nwhile (!postOrgasmDuration.complete) {\n  yield finishStroke.next();\n}\n\n/**\n * Try not to stop in the middle of a stroke...\n */\nconst nextStrokeAngle = Math.PI * (Math.floor(finishStroke.angle / Math.PI) + 1);\nwhile (finishStroke.angle < nextStrokeAngle) {\n  yield finishStroke.next();\n}\n\n/**\n * End by moving slowly back to home position.\n */\nyield ayva.$\n  .stroke({ \n    to: 0.5, duration: 4, value: Ayva.RAMP_PARABOLIC })\n  .surge(0.5)\n  .sway(0.5)\n  .twist(0.5)\n  .roll(0.5)\n  .pitch(0.5);\n\nayva.stop();\n"
    }
  }
]